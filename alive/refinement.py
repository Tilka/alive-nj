'''
Refinement checking for optimizations.
'''

from . import config
from . import error
from . import smtinterp
import z3
import glob
import logging
import time
from .language import *
from .z3util import mk_and, mk_not, mk_forall

logger = logging.getLogger(__name__)

PRESAFE, TGTSAFE, UB, POISON, UNEQUAL = range(5)

def check(opt, type_model, encoding=config.encoding, assume_inhabited=False):
  """Check that opt is a refinement for the given type_model.
  Raises Error if the opt is not a refinement. Returns false if opt
  is trivial (that is, the precondition cannot be satisfied. Otherwise,
  returns true.

  Keywords:
  encoding: specify an encoding using a string or SMTEncoder class
  assume_inhabited: if true, do not check whether the precondition is satisfied.
  """
  logger.info('Checking refinement of %r', opt.name)

  encoding = smtinterp.lookup(encoding)
  smt = encoding(type_model)

  asm = smt.conjunction(opt.asm)
  premise = asm.aux + asm.safe + asm.value
  if asm.defined or asm.nonpoison:
    raise Exception('Defined/Non-poison condition declared by assumption')

  pre = smt.conjunction(opt.pre)
  premise += pre.aux
  if pre.defined or pre.nonpoison:
    raise Exception('Defined/Non-poison condition declared by precondition')

  src = smt(opt.src)
  if src.aux:
    raise Exception('Auxiliary condition declared by source')

  tgt = smt(opt.tgt)
  premise += tgt.aux

  def check_expr(stage, expr):
    m = satisfiable(expr, opt.name, _stage_name[stage])
    if m is not None:
      raise CounterExampleError(stage, m, type_model, opt.src, src.value,
              tgt.value, encoding)

  if pre.safe:
    check_expr(PRESAFE, mk_and(premise + [mk_not(pre.safe)]))

  premise += pre.value

  inhabited = assume_inhabited or \
    satisfiable(mk_and(premise), opt.name, 'inhabited') is not None

  if tgt.safe:
    check_expr(TGTSAFE, mk_and(premise + [mk_not(tgt.safe)]))

  premise += src.defined
  if config.poison_undef:
    premise += src.nonpoison

  if tgt.defined:
    expr = premise + [mk_not(tgt.defined)]
    check_expr(UB, mk_forall(src.qvars, expr))

  if not config.poison_undef:
    premise += src.nonpoison

  if tgt.nonpoison:
    check_expr(POISON, mk_forall(src.qvars, premise + [mk_not(tgt.nonpoison)]))

  check_expr(UNEQUAL,
    mk_forall(src.qvars, premise + [z3.Not(src.value == tgt.value)]))

  return inhabited


_stage_name = {
  PRESAFE: 'precondition safety',
  TGTSAFE: 'target safety',
  UB:      'undefined behavior',
  POISON:  'poison',
  UNEQUAL: 'equality',
}

header = '''(set-info :source |
 Generated by Alive-NJ
 More info in N. P. Lopes, D. Menendez, S. Nagarakatte, J. Regehr.
 Provably Correct Peephole Optimizations with Alive. In PLDI'15.
|)
'''


def satisfiable(expr, opt_name='<unknown opt>', stage='<unknown>'):
  """Return a model satisfying the SMT expression, if any. Return None if
  the expression is unsatisfiable. Raise Error if the solver cannot determine
  satisfiability.
  """
  s = z3.Solver()
  if config.timeout is not None:
    s.set('timeout', config.timeout)
  s.add(expr)
  logger.debug('%s check for %s\n%s', stage, opt_name, s)

  time_start = time.time()
  res = s.check()
  time_end = time.time()

  solve_time = time_end - time_start

  if logger.isEnabledFor(logging.DEBUG):
    logger.debug('\nresult: %s\ntime: %s\nstats\n%s', res, solve_time,
      s.statistics())

  if config.bench_dir and solve_time >= config.bench_threshold:
    files = glob.glob(config.bench_dir + '/*.smt2')
    filename = '{0}/{1:03d}.smt2'.format(config.bench_dir, len(files))
    logger.debug('Writing benchmark file %r', filename)
    fd = open(filename, 'w')
    fd.write(header)
    fd.write('; {0} check for {1!r}\n'.format(stage, opt_name))
    fd.write('; time: {0} s\n\n'.format(solve_time))
    fd.write(s.to_smt2())
    fd.close()

  if res == z3.sat:
    m = s.model()
    logger.debug('counterexample: %s', m)

    return m

  if res == z3.unknown:
    raise Error('Model returned unknown: ' + s.reason_unknown())

  return None


def format_z3val(val):
  if isinstance(val, z3.BitVecNumRef):
    w = val.size()
    u = val.as_long()
    s = val.as_signed_long()

    if u == s:
      return '0x{1:0{0}x} ({1})'.format((w+3)/4, u)
    return '0x{1:0{0}x} ({1}, {2})'.format((w+3)/4, u, s)

  if isinstance(val, z3.FPRef):
    return str(val)

class Error(error.Error):
  pass

class CounterExampleError(Error):
  def __init__(self, cause, model, types, src, srcv, tgtv, trans):
    self.cause = cause
    self.model = model
    self.types = types
    self.src   = src
    self.srcv  = srcv
    self.tgtv  = tgtv
    self.trans = trans

  cause_str = {
    PRESAFE: 'Precondition is unsafe',
    TGTSAFE: 'Target is unsafe',
    UB:      'Target introduces undefined behavior',
    POISON:  'Target introduces poison',
    UNEQUAL: 'Mismatch in values',
    }

  def __str__(self):

    smt = self.trans(self.types)

    vars = [v for v in proper_subterms(self.src)
              if isinstance(v, (Input, Instruction))]

    ty_width = 1
    name_width = 1
    rows = []
    for v in vars:
      ty = str(self.types[v])
      ty_width = max(ty_width, len(ty))

      name = v.name
      name_width = max(name_width, len(name))

      interp = smt(v)

      if z3.is_false(self.model.evaluate(mk_and(interp.nonpoison))):
        # FIXME: make sure interp.nonpoison fully evaluates
        # e.g., what if it depends on a qvar somehow?
        rows.append((ty, name, 'poison'))

      else:
        val = self.model.evaluate(smt.eval(v), model_completion=True)
        # this will pick arbitrary values for any source qvars or
        # other unconstrained values

        rows.append((ty, name, format_z3val(val)))

    interp = smt(self.src)
    if z3.is_false(self.model.evaluate(mk_and(interp.nonpoison))):
      srcval = 'poison'
    else:
      srcval = format_z3val(self.model.evaluate(self.srcv, True))

    if self.cause == UB:
      tgtval = 'undefined'
    elif self.cause == POISON:
      tgtval = 'poison'
    else:
      tgtval = format_z3val(self.model.evaluate(self.tgtv, True))

    return '''{cause} for {srcty} {src}

Example:
{table}
source: {srcval}
target: {tgtval}'''.format(
      cause = self.cause_str[self.cause],
      srcty = self.types[self.src],
      src = self.src.name,
      table = '\n'.join(
        '{0:>{1}} {2:{3}} = {4}'.format(ty, ty_width, name, name_width, val)
        for ty, name, val in rows),
      srcval = srcval,
      tgtval = tgtval,
    )
